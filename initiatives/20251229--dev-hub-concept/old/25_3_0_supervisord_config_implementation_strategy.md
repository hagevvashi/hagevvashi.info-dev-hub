# SupervisordおよびProcess-Compose設定ファイルの2層構造実装戦略

**作成日**: 2026-01-03  
**目的**: Geminiのフィードバックに基づくsupervisord設定の改善を立案し、Monolithic DevContainerの堅牢性を向上させる。  

## １．課題（目標とのギャップ）
現在のsupervisord設定は、インフラファイルと開発者設定が混在しており、ビルド時の検証と起動時の柔軟性が不足。結果として、マウント失敗時の偽陽性（Upなのに実質動いていない状態）が発生し、開発効率が低下。目標である「安定した開発環境」の実現と、Geminiの指摘（分離の優位性とFail Fastの必要性）とのギャップを埋める。

## ２．原因
- **インフラと設定の混在**: `.devcontainer`配下に全設定を配置していたため、開発者がインフラファイルを誤って編集するリスク。
- **検証タイミングの欠如**: ビルド時のみのチェックでは、マウント設定のエラーを早期発見できず、鶏と卵の問題（検証しようとする設定がマウント依存）が発生。
- **フォールバックメカニズムの不在**: 設定エラー時にコンテナが完全に起動せず、デバッグが困難。

## ３．目的（あるべき状態）
- **堅牢な2層構造**: シード設定（インフラ）と実運用設定（カスタム）を分離し、ビルド時検証とランタイムフォールバックを確保。supervisord と process-compose の両方に適用。
- **Fail Fastと透明性**: 設定エラーを即時検知し、Web UIで状態を可視化。code-serverのみのフォールバックでデバッグを可能に。
- **開発者体験の向上**: 共通設定と個人設定の共存をサポートし、マウント失敗時も最低限の環境を提供。

## ４．戦略・アプローチ（解決の方針）
- **分離原則の適用**: インフラファイル（.devcontainer）は不変とし、ユーザ設定（組織・プロジェクト設定）はGit管理下でもOKだが、DockerfileのCOPY対象ではなくバインドマウント対象として配置。
- **段階的検証**: ビルド時はシード設定のみ検証、起動時は実運用設定をチェックし、エラー時はフォールバック。
- **テスト駆動実装**: プロトタイプから開始し、偽陽性シナリオをテストして調整。
- **ドキュメント主導**: 各変更を詳細に記録し、オンボーディングを容易化。

## ５．解決策 (少なくとも3つの異なる、比較可能な解決策)
### 解決策1: 最小限の2層構造（推奨）
- **概要**: `.devcontainer/supervisord/seed_supervisord.conf`（COPY）と`foundations/operations/supervisord/`（バインドマウント）のシンプル分離。
- **利点**: 実装が簡単で、既存構造との整合性が高い。フォールバックがcode-serverのみと明確。
- **欠点**: 個人設定の分離が不十分で、Gitコミット時にノイズが発生する可能性。
- **実装ステップ**: DockerfileにCOPY追加、devcontainer.jsonにmount指定、検証スクリプト更新。
- **比較ポイント**: 他の解決策より保守性が低いが高速実装可能。

### 解決策2: 拡張2層構造（柔軟性重視）
- **概要**: 解決策1に組織・プロジェクト共通設定ファイル（例: `project_supervisord.conf`）を追加し、includeで統合。仮に個人設定が必要な場合、**/supervisord/*.local.conf のようなパターンを .gitignore に追加してGit管理外とする。
- **利点**: プロジェクト共通設定をチーム間で共有可能にし、設定競合を回避。チーム開発に適する。
- **欠点**: スクリプトが複雑化し、初回セットアップの学習コストが増大。
- **実装ステップ**: プロジェクト設定用のディレクトリ作成、includeロジック追加、ドキュメント更新。
- **比較ポイント**: 解決策1より堅牢だが、実装時間が長く、Git管理の考慮が必要。

### 解決策3: runtime/ ディレクトリ配置（実行時設定特化アプローチ）
- **概要**: トップレベルに新しい `runtime/` ディレクトリを作成し、その中に `supervisord/` と `process-compose/` サブディレクトリを配置。実運用設定を `runtime/supervisord/project.conf` などに置き、バインドマウント対象とする。process-compose も同様にシードと運用の2層構造を適用。これにより、開発環境の実行時設定をまとめて、将来の拡張（例: runtime/healthchecks/, runtime/volumes/）に備える。
- **利点**: プロジェクトの構造を明確にし、設定ファイルの場所を統一。Git管理下で組織・プロジェクト設定を共有可能。トップレベルのディレクトリ追加により、実行時関連設定の拡張に備える。プロセス管理中心で狭すぎず、汎用的すぎないバランス。
- **欠点**: 既存構造に新しいディレクトリを追加するため、移行コストがかかる。初期セットアップで .gitignore の調整が必要。
- **実装ステップ**: `runtime/` ディレクトリ作成、`runtime/supervisord/` と `runtime/process-compose/` に設定ファイル配置、devcontainer.jsonでバインドマウント、ドキュメント更新。
- **比較ポイント**: 解決策2より構造化され、長期保守性が高いが、シンプルさを犠牲にする。

#### ディレクトリ命名の考察
レポジトリ名に "dev" が含まれるため、ディレクトリ名に "dev" を重ねないよう `runtime/` と `operations/` を比較検討した。

- **runtime/ のイメージと配置シミュレーション**:
  - イメージ: 開発環境の実行時設定をまとめたディレクトリ。コンテナ起動時に必要なプロセス、環境、ネットワークなどの実行時振る舞いを定義。将来、環境別設定（例: runtime/staging/）の拡張も可能。
  - 配置例:
    - runtime/supervisord/project.conf (プロジェクト固有のsupervisord設定)
    - runtime/process-compose/project.yml (process-composeの設定)
    - runtime/healthchecks/http-check.sh (ヘルスチェックスクリプト)
    - runtime/volumes/postgres-data/ (ボリュームマウント設定)
    - runtime/env/.env (環境変数ファイル)

- **operations/ のイメージと配置シミュレーション**:
  - イメージ: 運用操作に関する設定をまとめたディレクトリ。プロセス管理だけでなく、監視、ログ、バックアップなどの運用タスクを定義。DevOpsチームが管理するイメージ。
  - 配置例:
    - operations/supervisord/project.conf (supervisord設定)
    - operations/process-compose/project.yml (process-compose設定)
    - operations/monitoring/prometheus.yml (監視設定)
    - operations/logs/rotation.conf (ログローテーション設定)
    - operations/backup/schedule.sh (バックアップスクリプト)

- **採用理由**: 今回のプロセス管理中心のタスクに対し、runtime/ は実行時設定に特化しており、スッキリ収まる。operations/ は運用タスクに広げられるが、狭すぎず汎用的すぎないバランスで runtime/ を選択。

### 解決策4: APIベースのダイナミック構成（先進的アプローチ）
- **概要**: process-composeのAPIを活用し、supervisord設定をランタイム生成。マウント設定をJSONベースで管理。
- **利点**: 設定ミスをプログラム的に防ぎ、Web UIとの統合が強力。将来の拡張性が高い。
- **欠点**: 既存ツールチェーンとの互換性が低く、学習曲線が急。初期実装コストが高い。
- **実装ステップ**: process-composeの設定ファイル作成、supervisordのincludeをAPI経由に変更、テスト自動化。
- **比較ポイント**: 他の解決策より革新的だが、リスクが高く、Monolithic DevContainerのシンプルさを損なう可能性。

## 結論と次のステップ
- **推奨解決策**: 解決策3（新しいトップレベルディレクトリ配置）を採用。構造化され、長期保守性と拡張性が高く、トップレベルの整理に貢献する。
- **実装計画**: まず27_6_supervisord_implementation_prototype.mdを作成し、小規模テストを実施。成功後に本格実装。
- **リスク軽減**: 各ステップでテスト環境検証を行い、ロールバック計画を用意。