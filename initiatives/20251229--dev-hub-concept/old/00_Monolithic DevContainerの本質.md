# Monolithic DevContainerの本質

## 課題（目標とのギャップ）

**「開発環境の差異」による開発スループットの低下。**

具体的には：
- 「私の環境では動くんですけど…」問題が頻発する
- 新メンバーのオンボーディングに丸一日かかる
- AIエージェント（Devin、Cursor）が動かすコードと人間が動かすコードで挙動が違う

## 原因

**ローカル開発が前提になっている。**

AIネイティブ時代、Cursorなどのエディタを使いたい。クラウドIDEではなくローカルで動かしたい。しかしローカル開発は、言語ランタイム・ミドルウェア・フレームワークのインストールが各自のOS・パッケージマネージャーに依存する。Homebrewのバージョン、Nodeのバージョン、Pythonの入れ方…すべてがバラバラになる。

さらに、複数プロダクトを横断して開発する場合、「プロダクトAはNode 18、プロダクトBはNode 20」のような状況が生まれ、ローカル環境が複雑化・属人化していく。

## 目的（あるべき状態）

**「環境」を考えなくていい開発体験。**

- 誰が・どのマシンで開発しても、同一の環境で動く
- 複数プロダクトを横断的に、シームレスに開発できる
- 「環境構築」という作業が存在しない（clone → 開発開始）

## 解決のアプローチ（重要な設計判断）

**Monolithic DevContainer = 「すべてをコンテナ上で開発する」**

ここでの重要な設計判断は3つ：

1. **「プロジェクトごとのDevContainer」ではなく「組織で1つの巨大なDevContainer」**
   - プロジェクトごとにDevContainerを持つと、プロジェクトを切り替えるたびにコンテナを立て直す必要がある。横断開発には向かない
   - 1つの「全部入り」コンテナに入れば、その中で複数プロダクトを自由に行き来できる

2. **「ホストOSにマウント」ではなく「コンテナ内に閉じる」**
   - ホストとコンテナ間のファイル共有は、OSの差異を持ち込んでしまう（パーミッション、パフォーマンス）
   - コンテナ内で完結させることで、「どのホストOSから接続しても同じ」を実現する

3. **「環境定義」と「プロダクトコード」の分離**
   - 環境定義（dev-platform）はチーム共通でGit管理
   - プロダクトコードは環境の中に展開される「ゲスト」として扱う
   - これにより、環境のバージョンアップとプロダクト開発を独立して進められる